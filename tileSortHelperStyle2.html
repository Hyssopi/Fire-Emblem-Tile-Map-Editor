
<!DOCTYPE html>
<html>
  <link href="styles/fontawesome-free-5.11.2-web/css/all.css" rel="stylesheet">
  <link href="styles/styles.css" rel="stylesheet"/>
  
  <head>
    <meta charset="UTF-8">
    <title>Tile Sort Helper Style 2</title>
  </head>
  
  <body>
    <div class="flexBoxColumn" style="text-align: start;">
      <div id="topDisplayId" style="width: 100%; height: 1500px; overflow: auto; border: yellow 1px solid; background-color: black;">
      </div>

      <div style="width: 100%; height: 200px; overflow: auto; border: yellow 1px solid; background-color: black;">
        <ul id="bottomDisplayId" style="padding: 0px; margin: 0px;"></ul>
      </div>

      <button id="importMapFileButtonId" class="font-awesome-icons" title="Import">
        <i class="fa fa-folder-open"></i>
      </button>
      <input id="importMapFileInputId" type="file" style="display: none;"/>

      <div id="outputTileGroupBlockId"></div>

      <div>
        <textarea id="moveScriptOutputId" style="width: 100%;" readonly>
        </textarea>
      </div>
    </div>
  </body>
  
  <style>
    /*
      Adjust styling
    */
    body
    {
      color: white;
      background-color: black;
    }

    /*
      Adjust to resize image margin and disable hover effects
    */
    img
    {
      margin: 1px;
    }
    img:hover
    {
      margin: 1px;
      border: 0px #ADD8E6 solid;
    }
  </style>

  <script>
    const Ids =
    {
      topDisplay: 'topDisplayId',
      bottomDisplay: 'bottomDisplayId',
      importMapFileButton: 'importMapFileButtonId',
      importMapFileInput: 'importMapFileInputId',
      outputTileGroupBlock: 'outputTileGroupBlockId',
      moveScriptOutput: 'moveScriptOutputId'
    };
    
    const BASE_IMAGE_DIRECTORY_PATH = 'C:\\Users\\t\\Desktop\\temp9\\tiles\\images';
    
    const TILE_WIDTH = 16;
    const TILE_HEIGHT = 16;
    
    const BASE_OUTPUT_DIRECTORY_PATH = 'tiles';
    const IMAGES_OUTPUT_FOLDER_NAME = 'images';
    
    const BackgroundColor =
    {
      valid: 'white',
      invalid: 'red'
    };
    
    const TILE_GROUP_INPUT_OPTIONS =
    [
      "ARENA",
      "ARMORY",
      "BARREL",
      "BONE",
      "BRACE",
      "BRIDGE",
      "CHEST",
      "CLIFF",
      "CLOSED",
      "CURSOR",
      "DARK",
      "DASHDASH",
      "DECK",
      "DEEPS",
      "DESERT",
      "DOOR",
      "EMPTY",
      "FE6TEMP",
      "FE7TEMP",
      "FE8TEMP",
      "FENCE",
      "FLAT",
      "FLOOR",
      "FOREST",
      "FORT",
      "GATE",
      "GUNNEL",
      "GUNNELS",
      "HOUSE",
      "INN",
      "LAKE",
      "MAST",
      "MOUNTAIN",
      "PEAK",
      "PILLAR",
      "PLAIN",
      "RIVER",
      "ROAD",
      "ROOF",
      "RUINS",
      "SAND",
      "SEA",
      "SKY",
      "SNAG",
      "STAIRS",
      "TEMP",
      "THICKET",
      "THRONE",
      "UNDEFINED",
      "VALLEY",
      "VENDOR",
      "VILLAGE",
      "WALL",
      "WATER"
    ];

    const LOAD_MAP_AMOUNT = 3;

    const INPUT_MAP_FILE_PATHS =
    [
      "C:\\Users\\t\\Desktop\\temp9\\References\\Fire Emblem Map JSON Files\\Fire Emblem 8\\Chapters\\01\\001.png.json",
      "C:\\Users\\t\\Desktop\\temp9\\References\\Fire Emblem Map JSON Files\\Fire Emblem 8\\Chapters\\02\\001.png.json",
      "C:\\Users\\t\\Desktop\\temp9\\References\\Fire Emblem Map JSON Files\\Fire Emblem 8\\Chapters\\03\\001.png.json",
      "C:\\Users\\t\\Desktop\\temp9\\References\\Fire Emblem Map JSON Files\\Fire Emblem 8\\Chapters\\04\\001.png.json"
    ];

    let tileImagesReference = [];
    let doNotShowTileHashes = [];

    let topTileHashes = [[]];
    let bottomTileHashes = [];
    

    start();
    

    /**
     * Start the editor.
     */
    function start()
    {
      // Resets data
      tileImagesReference.splice(0, tileImagesReference.length);
      topTileHashes.splice(0, topTileHashes.length);
      bottomTileHashes.splice(0, bottomTileHashes.length);

      // Add Empty Tile to reference
      let tileEmptyImageSource = BASE_OUTPUT_DIRECTORY_PATH + '/' + IMAGES_OUTPUT_FOLDER_NAME + '/' + 'EMPTY' + '/' + 'b96808283004c0f124a18b2b9670d1c0' + '.png';
      let emptyTileImage = new Image();
      emptyTileImage.src = tileEmptyImageSource;
      tileImagesReference['b96808283004c0f124a18b2b9670d1c0'] = emptyTileImage;

      setupEventListeners(tileImagesReference);
      setupUI();
    }
    
    /**
     * Setup event listeners.
     * 
     * @param tileImagesReference Contains the tile images with the assumption that it is in the specified group, tile hash is the key
     */
    function setupEventListeners(tileImagesReference)
    {
      // Prevent auto-scrolling when middle clicked
      document.body.onmousedown = function(event)
      {
        if (event.button === 1)
        {
          return false;
        }
      }
      
      document.addEventListener('keydown',
        function(event)
        {
          // Redraw/update the left and right displays when user presses 'u' or 'r'
          if (event.key === 'u' || event.key === 'r')
          {
            updateAll(tileImagesReference);
          }
        });

      document.getElementById(Ids.importMapFileButton).addEventListener('click',
        function()
        {
          let input = document.getElementById(Ids.importMapFileInput);
          input.click();
        });

      document.getElementById(Ids.importMapFileInput).onchange = event =>
        {
          let file = event.target.files[0];
          let reader = new FileReader();
          reader.readAsText(file, 'UTF-8');
          
          reader.onload = readerEvent =>
          {
            let fileContent = readerEvent.target.result;
            let mapJson = JSON.parse(fileContent);
            //console.log(mapJson);

            addMapJsonToTop(tileImagesReference, topTileHashes, mapJson);
            updateAll(tileImagesReference);
            // Maybe copy to clipboard?
            
            console.log('\"' + file.name + '\" map has been loaded.');
          }
        }
    }
    
    /**
     * Setup any additional UI.
     */
    function setupUI()
    {
      // TODO: Add tile group buttons
    }
    
    function addMapJsonToTop(tileImagesReference, topTileHashes, mapJson)
    {
      for (let y = 0; y < mapJson.length; y++)
      {
        let newTileRow = [];
        for (let x = 0; x < mapJson[y].length; x++)
        {
          
          let groupFolderName = 'UNDEFINED';

          let tileImageSource = BASE_OUTPUT_DIRECTORY_PATH + '/' + IMAGES_OUTPUT_FOLDER_NAME + '/' + groupFolderName + '/' + mapJson[y][x] + '.png';

          newTileRow.push(mapJson[y][x]);
          
          getImage(tileImageSource, function(tileImage)
          {
            console.log('Tile Image exists: ' + (tileImage !== null));

            if (!tileImagesReference[mapJson[y][x]])
            {
              // Only add to the reference and the right display if the tile image exists in the specified group folder
              tileImagesReference[mapJson[y][x]] = tileImage;
            }

            if (tileImage === null)
            {
              doNotShowTileHashes.push(mapJson[y][x]);
            }
          });
        }
        topTileHashes.push(newTileRow);
      }

      /**
       * Try and load an image given the source.
       * If the image exists, then it returns the image in the callback. Otherwise it returns null in the callback.
       * 
       * @param url Input source, for example: path to an image file on computer
       * @param callback Callback function used to get the return image
       */
      function getImage(url, callback)
      {
        let image = new Image();
        image.onload = function() { callback(image); };
        image.onerror = function() { callback(null); };
        image.src = url;
      }
    }








    /*
    function moveToOther(originDisplayId, x, y)
    {
      if (originDisplayId === Ids.bottomDisplay)
      {
        let tileHash = leftTileHashes.splice(index, 1);
        rightTileHashes.push(tileHash);
      }
      else if (originDisplayId === Ids.topDisplay)
      {
        let tileHash = rightTileHashes.splice(index, 1);
        leftTileHashes.push(tileHash);
      }
    }
    */
    
    /**
     * Update / redraw GUI.
     * 
     * @param tileImagesReference Contains the tile images with the assumption that it is in the specified group, tile hash is the key
     */
    function updateAll(tileImagesReference)
    {
      redrawDisplay(tileImagesReference, Ids.topDisplay, topTileHashes);
      redrawDisplay(tileImagesReference, Ids.bottomDisplay, bottomTileHashes);
      
      console.log('\n');
      //console.log('TOP has: ' + topTileHashes.length + ' tiles');
      console.log('BOTTOM has: ' + bottomTileHashes.length + ' tiles');
      console.log('\n');
      
      updateMoveScriptOutput();
    }
    
    /**
     * Redraw the tile display.
     * 
     * @param tileImagesReference Contains the tile images with the assumption that it is in the specified group, tile hash is the key
     * @param displayId Display ID, either left or right
     * @param tileHashes List of tile hashes to display
     */
    function redrawDisplay(tileImagesReference, displayId, tileHashes)
    {
      let displayDiv = document.getElementById(displayId);
      displayDiv.innerHTML = '';

      if (displayId == Ids.topDisplay)
      {
        let newDivGridReference = [];
        for (let y = 0; y < tileHashes.length; y++)
        {
          let newDivRow = document.createElement('div');
          newDivRow.classList.add('flexBoxRow');
          let newDivRowReference = [];
          for (let x = 0; x < tileHashes[y].length; x++)
          {
            let newDiv = document.createElement('div');
            newDiv.id = 'tile:' + x + ',' + y;

            newDivRow.appendChild(newDiv);
            newDivRowReference.push(newDiv);
          }
          displayDiv.appendChild(newDivRow);
          newDivGridReference.push(newDivRowReference);
        }

        
        for (let y = 0; y < tileHashes.length; y++)
        {
          for (let x = 0; x < tileHashes[y].length; x++)
          {
            let tileImage = new Image(TILE_WIDTH * 4, TILE_HEIGHT * 4);
            let tileHash = '';

            if (doNotShowTileHashes.includes(tileHashes[y][x]))
            {
              tileHash = 'b96808283004c0f124a18b2b9670d1c0';
            }
            else
            {
              tileHash = tileHashes[y][x];

              /*
              tileImage.addEventListener('mouseup',
                function(event)
                {
                  if (event.button === 0)
                  {
                    // Left mouse click
                    moveToOther(displayId, i);
                  }
                }, false);
              tileImage.addEventListener('contextmenu',
                function(event)
                {
                  // Right click, prevent context menu from showing
                  event.preventDefault();
                }, false);
              */
            }

            tileImage.src = tileImagesReference[tileHash].src;
            
            newDivGridReference[y][x].appendChild(tileImage);
            //document.getElementById('tile:' + x + ',' + y).appendChild(tileImage);
          }
        }
      }
      else if (displayId == Ids.bottomDisplay)
      {

      }




      /*
      let unorderedList = document.getElementById(displayId);
      unorderedList.innerHTML = '';
      
      for (let i = 0; i < tileHashes.length; i++)
      {
        let tileHash = tileHashes[i];
        
        let listItem = document.createElement('li');
        listItem.title = i;
        
        let tileImage = new Image(TILE_WIDTH * 4, TILE_HEIGHT * 4);
        tileImage.src = tileImagesReference[tileHash].src;
        tileImage.addEventListener('mouseup',
          function(event)
          {
            if (event.button === 0)
            {
              // Left mouse click
              moveToOther(displayId, i);
            }
          }, false);
        tileImage.addEventListener('contextmenu',
          function(event)
          {
            // Right click, prevent context menu from showing
            event.preventDefault();
          }, false);
        
        listItem.appendChild(tileImage);
        
        unorderedList.appendChild(listItem);
      }
      */
    }
    
    /**
     * Update move script output text area. Commands to copy and paste as a batch script to mass move tile images from input specified group to the output specified TILE GROUP.
     */
    function updateMoveScriptOutput()
    {
      /*
      let inputTileGroup = document.getElementById(Ids.tileGroupInputDropDown).value;
      let outputTileGroup = document.getElementById(Ids.tileGroupOutputDropDown).value;
      
      document.getElementById(Ids.tileGroupOutputDropDown).style.backgroundColor = outputTileGroup === '' ? BackgroundColor.invalid : BackgroundColor.valid;
      document.getElementById(Ids.moveScriptOutput).style.backgroundColor = outputTileGroup === '' ? BackgroundColor.invalid : BackgroundColor.valid;
      */
      
      let inputTileGroup = 'UNDEFINED';
      let outputTileGroup = 'TEMP';

      let moveScriptOutput = '';
      moveScriptOutput += 'cd ' + BASE_IMAGE_DIRECTORY_PATH + '\n';
      for (let tileHash of bottomTileHashes)
      {
        let moveScriptCommand =
          'move'
          + ' ' + inputTileGroup + '\\' + tileHash + '.png'
          + ' ' + outputTileGroup;
        moveScriptOutput += moveScriptCommand + '\n';
      }
      document.getElementById(Ids.moveScriptOutput).value = moveScriptOutput;

      copyTextToClipboard(moveScriptOutput);
    }

    /**
     * TODO: From utilities.js
     * Copy text to clipboard.
     *
     * @param text Text to put to clipboard
     */
    function copyTextToClipboard(text)
    {
      let textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.textContent = text;
      document.body.appendChild(textArea);
      
      let range = document.createRange();
      range.selectNode(textArea);
      let selection = document.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      
      document.execCommand('copy');
      
      selection.removeAllRanges();
      document.body.removeChild(textArea);
    }
  </script>
</html>
